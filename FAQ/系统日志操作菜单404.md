## 问题场景

- Mac 本地按照 `./setup.sh` 与 `./start.sh` 启动项目。
- 登录后台后，点击 “系统管理 → 日志管理 → 操作日志” 或直接访问 `http://localhost/system/log/operlog`，页面始终跳转到 404。
- 工程管理菜单中的 “操作日志” 可以正常进入，只有系统管理下面的日志页失效。

## 原因分析

1. `sys_menu` 表中存在两条 `path=operlog` 的菜单：  
   - `menu_id=500`：系统管理 → 日志管理 → 操作日志。  
   - `menu_id=119`：工程管理 → 操作日志（通过 `update_project_menu.sql` 插入）。  
2. 两条菜单都没有显式设置 `route_name`。前端在转换动态路由时，会使用 `path` 作为 name（`Operlog`），导致生成的两个路由重名。  
3. Vue Router 要求路由 name 唯一。同名路由注册时，后者会覆盖前者，结果是：只剩下工程管理的操作日志能访问，而系统管理的路由被覆盖后访问 404。

## 解决方案

1. **为工程管理的操作日志补充唯一的 `route_name`**  
   ```sql
   UPDATE sys_menu
   SET route_name = 'projectOperLog'
   WHERE menu_id = 119;
   ```
   你也可以直接重新执行 `ruoyi-fastapi-backend/sql/project.sql`，其中已内置该字段。
2. **执行脚本后重启 / 刷新前端**  
   - `./start.sh` 运行中，按 `Ctrl+C` 停止，再重新执行 `./start.sh`。  
   - 浏览器端退出登录或清空本地缓存，让前端重新获取路由。  
3. **再次访问**  
   - 点击 “系统管理 → 日志管理 → 操作日志” 或访问 `http://localhost/system/log/operlog`，页面即可恢复正常；工程管理下的操作日志仍可正常使用。

> 补充：如果之前执行了临时修复脚本（例如 `fix_admin_log_menu.sql`、`fix_project_operlog_route_name.sql`），在数据库确认权限与 `route_name` 已正确写入后，可以删除这些脚本，避免仓库中出现冗余的临时 SQL。

---

## 问题场景：协议类型字典在前端始终为空

- 已执行 `ruoyi-fastapi-backend/sql/protocol.sql`，能在数据库的 `sys_dict_type`、`sys_dict_data` 中看到 `sys_protocol_type`。
- 前端 `DictSelect` 组件通过 `/system/dict/data/type/sys_protocol_type` 请求，控制台打印 `response.data = []`，协议相关下拉无法选择。
- 刷新缓存或重启 Redis 也可能导致同样的问题。

## 原因分析

1. 后端接口 `DictDataService.query_dict_data_list_from_cache_services` 只尝试从 Redis 读取键 `sys_dict:sys_protocol_type`。  
2. 如果缓存未命中（例如新部署、脚本刚写入数据库尚未刷新缓存、Redis 重启之后），函数直接返回空数组，不会回源数据库。  
3. 前端的 `<DictSelect>` 组件只依赖这次返回结果，自然得不到任何字典项，看起来像“数据库有数据但是接口始终为空”。

## 解决方案 / 优化点

1. **缓存穿透处理**  
   在 `ruoyi-fastapi-backend/module_admin/service/dict_service.py` 中，为 `DictDataService.query_dict_data_list_from_cache_services` 新增数据库回源逻辑：  
   ```python
   cache_key = f'{RedisInitKeyConfig.SYS_DICT.key}:{dict_type}'
   dict_data_list_result = await redis.get(cache_key)
   if dict_data_list_result:
       result = json.loads(dict_data_list_result)
   else:
       async with AsyncSessionLocal() as session:
           dict_data_list = await DictDataDao.query_dict_data_list(session, dict_type)
       dict_data = [CamelCaseUtil.transform_result(row) for row in dict_data_list if row]
       await redis.set(cache_key, json.dumps(dict_data, ensure_ascii=False, default=str))
       result = dict_data
   ```
   - 缓存 miss 时自动查询数据库并回写缓存，让前端永远能拿到最新数据。  
   - 大多数请求仍走 Redis，不会牺牲性能。

2. **无须额外操作**  
   部署此改动后，前端重新发起字典请求即可。即便 Redis 未提前预热，也会在首次请求时自动填充缓存。

3. **适用范围**  
   该优化对所有依赖字典缓存的模块（协议管理、任务管理、日志导出等）都生效，避免类似“数据库有数据但接口为空”的问题重复出现。
