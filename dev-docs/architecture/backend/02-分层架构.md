# 分层架构

## 架构概述

后端采用经典的分层架构模式,将应用程序分为四个主要层次,每层都有明确的职责和边界。

## 四层架构

```
┌─────────────────────────────────────┐
│      Controller 层 (控制器层)        │  ← HTTP 请求入口
│  - 路由定义                          │
│  - 请求验证                          │
│  - 响应格式化                        │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│       Service 层 (业务逻辑层)        │  ← 核心业务逻辑
│  - 业务规则                          │
│  - 事务管理                          │
│  - 数据转换                          │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│        DAO 层 (数据访问层)           │  ← 数据库操作
│  - CRUD 操作                         │
│  - 查询构建                          │
│  - 数据映射                          │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      Database 层 (数据库层)          │  ← 数据持久化
│  - MySQL/PostgreSQL                  │
│  - Redis 缓存                        │
└─────────────────────────────────────┘
```

## 各层详解

### 1. Controller 层 (控制器层)

**职责**:
- 定义 API 路由和端点
- 接收和验证 HTTP 请求
- 调用 Service 层处理业务逻辑
- 格式化响应数据
- 处理权限验证

**文件位置**: `module_admin/controller/`

**命名规范**: `{模块名}_controller.py`

**示例代码**:
```python
from fastapi import APIRouter, Depends
from module_admin.annotation.log_annotation import Log
from module_admin.aspect.interface_auth import CheckUserInterfaceAuth
from module_admin.entity.vo.user_vo import UserQueryModel, UserModel
from module_admin.service.user_service import UserService
from utils.response_util import ResponseUtil

router = APIRouter(prefix="/system/user", tags=["用户管理"])

@router.get("/list", dependencies=[Depends(CheckUserInterfaceAuth("system:user:list"))])
@Log(title="用户管理", business_type=1)
async def get_user_list(
    query: UserQueryModel = Depends(),
    user_service: UserService = Depends()
):
    """
    获取用户列表
    """
    result = await user_service.get_user_list(query)
    return ResponseUtil.success(data=result)

@router.post("", dependencies=[Depends(CheckUserInterfaceAuth("system:user:add"))])
@Log(title="用户管理", business_type=2)
async def add_user(
    user: UserModel,
    user_service: UserService = Depends()
):
    """
    新增用户
    """
    await user_service.add_user(user)
    return ResponseUtil.success(msg="新增成功")
```

**关键点**:
- 使用 `APIRouter` 定义路由
- 通过 `Depends()` 实现依赖注入
- 使用装饰器进行权限控制和日志记录
- 不包含业务逻辑,只负责调用 Service

### 2. Service 层 (业务逻辑层)

**职责**:
- 实现核心业务逻辑
- 管理事务
- 调用 DAO 层进行数据操作
- 数据转换和验证
- 业务规则校验

**文件位置**: `module_admin/service/`

**命名规范**: `{模块名}_service.py`

**示例代码**:
```python
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Depends
from config.get_db import get_db
from module_admin.dao.user_dao import UserDao
from module_admin.entity.vo.user_vo import UserQueryModel, UserModel
from module_admin.entity.do.user_do import SysUser
from utils.pwd_util import PwdUtil
from exceptions.exception import ServiceException

class UserService:
    """
    用户服务类
    """
    
    def __init__(self, db: AsyncSession = Depends(get_db)):
        self.db = db
        self.user_dao = UserDao(db)
    
    async def get_user_list(self, query: UserQueryModel):
        """
        获取用户列表
        """
        # 调用 DAO 层查询数据
        users = await self.user_dao.get_user_list(query)
        total = await self.user_dao.get_user_count(query)
        
        return {
            "rows": users,
            "total": total
        }
    
    async def add_user(self, user: UserModel):
        """
        新增用户
        """
        # 业务规则验证
        existing_user = await self.user_dao.get_user_by_username(user.user_name)
        if existing_user:
            raise ServiceException(message="用户名已存在")
        
        # 密码加密
        user.password = PwdUtil.get_password_hash(user.password)
        
        # 调用 DAO 层保存数据
        user_do = SysUser(**user.dict())
        await self.user_dao.add_user(user_do)
        await self.db.commit()
```

**关键点**:
- 包含业务逻辑和规则验证
- 通过依赖注入获取数据库会话
- 调用 DAO 层进行数据操作
- 管理事务提交和回滚
- 抛出业务异常

### 3. DAO 层 (数据访问层)

**职责**:
- 封装数据库 CRUD 操作
- 构建 SQL 查询
- 数据库对象映射
- 不包含业务逻辑

**文件位置**: `module_admin/dao/`

**命名规范**: `{模块名}_dao.py`

**示例代码**:
```python
from sqlalchemy import select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession
from module_admin.entity.do.user_do import SysUser
from module_admin.entity.vo.user_vo import UserQueryModel

class UserDao:
    """
    用户数据访问类
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_user_list(self, query: UserQueryModel):
        """
        查询用户列表
        """
        stmt = select(SysUser)
        
        # 构建查询条件
        conditions = []
        if query.user_name:
            conditions.append(SysUser.user_name.like(f"%{query.user_name}%"))
        if query.status:
            conditions.append(SysUser.status == query.status)
        if query.dept_id:
            conditions.append(SysUser.dept_id == query.dept_id)
        
        if conditions:
            stmt = stmt.where(and_(*conditions))
        
        # 分页
        stmt = stmt.offset((query.page_num - 1) * query.page_size).limit(query.page_size)
        
        # 执行查询
        result = await self.db.execute(stmt)
        return result.scalars().all()
    
    async def get_user_count(self, query: UserQueryModel):
        """
        查询用户总数
        """
        stmt = select(func.count(SysUser.user_id))
        
        # 构建查询条件(同上)
        conditions = []
        if query.user_name:
            conditions.append(SysUser.user_name.like(f"%{query.user_name}%"))
        
        if conditions:
            stmt = stmt.where(and_(*conditions))
        
        result = await self.db.execute(stmt)
        return result.scalar()
    
    async def get_user_by_username(self, username: str):
        """
        根据用户名查询用户
        """
        stmt = select(SysUser).where(SysUser.user_name == username)
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()
    
    async def add_user(self, user: SysUser):
        """
        新增用户
        """
        self.db.add(user)
        await self.db.flush()
```

**关键点**:
- 只负责数据库操作,不包含业务逻辑
- 使用 SQLAlchemy 异步查询
- 返回数据库对象或查询结果
- 不直接提交事务(由 Service 层管理)

### 4. Entity 层 (实体层)

**职责**:
- 定义数据模型
- 数据验证
- 序列化和反序列化

**文件位置**: `module_admin/entity/`

**两种模型**:

#### DO (Database Object) - 数据库对象
**位置**: `entity/do/`
**用途**: 映射数据库表结构

```python
from sqlalchemy import Column, Integer, String, DateTime
from config.database import Base

class SysUser(Base):
    """
    用户表
    """
    __tablename__ = "sys_user"
    
    user_id = Column(Integer, primary_key=True, autoincrement=True, comment="用户ID")
    user_name = Column(String(30), nullable=False, comment="用户账号")
    nick_name = Column(String(30), nullable=False, comment="用户昵称")
    email = Column(String(50), comment="用户邮箱")
    phonenumber = Column(String(11), comment="手机号码")
    sex = Column(String(1), comment="用户性别")
    password = Column(String(100), comment="密码")
    status = Column(String(1), default="0", comment="帐号状态(0正常 1停用)")
    create_time = Column(DateTime, comment="创建时间")
    update_time = Column(DateTime, comment="更新时间")
```

#### VO (View Object) - 视图对象
**位置**: `entity/vo/`
**用途**: API 请求和响应模型

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class UserQueryModel(BaseModel):
    """
    用户查询模型
    """
    user_name: Optional[str] = None
    phonenumber: Optional[str] = None
    status: Optional[str] = None
    dept_id: Optional[int] = None
    page_num: int = Field(default=1, ge=1)
    page_size: int = Field(default=10, ge=1, le=100)

class UserModel(BaseModel):
    """
    用户模型
    """
    user_id: Optional[int] = None
    user_name: str = Field(..., min_length=1, max_length=30)
    nick_name: str = Field(..., min_length=1, max_length=30)
    email: Optional[str] = Field(None, max_length=50)
    phonenumber: Optional[str] = Field(None, max_length=11)
    sex: Optional[str] = None
    password: Optional[str] = None
    status: str = "0"
    
    class Config:
        from_attributes = True
```

## 层间交互规则

### 1. 单向依赖
```
Controller → Service → DAO → Database
```
- 上层可以调用下层
- 下层不能调用上层
- 同层之间可以相互调用

### 2. 数据流转
```
请求: VO → Service → DAO → DO → Database
响应: Database → DO → DAO → Service → VO
```

### 3. 异常处理
- DAO 层: 抛出数据库异常
- Service 层: 捕获并转换为业务异常
- Controller 层: 捕获并格式化为 HTTP 响应

## 最佳实践

### 1. Controller 层
- 保持轻量,只做路由和调用
- 使用 Pydantic 模型验证请求
- 统一响应格式
- 添加权限和日志装饰器

### 2. Service 层
- 包含所有业务逻辑
- 一个 Service 方法对应一个业务操作
- 管理事务边界
- 抛出明确的业务异常

### 3. DAO 层
- 只做数据库操作
- 方法命名清晰(get/add/update/delete)
- 使用异步查询
- 不直接提交事务

### 4. Entity 层
- DO 严格映射数据库表
- VO 根据 API 需求设计
- 使用 Pydantic 进行数据验证

## 完整示例

一个完整的用户查询流程:

```python
# 1. Controller 接收请求
@router.get("/list")
async def get_user_list(
    query: UserQueryModel = Depends(),  # VO 模型验证
    service: UserService = Depends()
):
    result = await service.get_user_list(query)
    return ResponseUtil.success(data=result)

# 2. Service 处理业务逻辑
async def get_user_list(self, query: UserQueryModel):
    # 调用 DAO 查询
    users = await self.user_dao.get_user_list(query)
    total = await self.user_dao.get_user_count(query)
    
    # 数据转换
    user_list = [UserModel.from_orm(user) for user in users]
    
    return {"rows": user_list, "total": total}

# 3. DAO 执行数据库查询
async def get_user_list(self, query: UserQueryModel):
    stmt = select(SysUser).where(...)
    result = await self.db.execute(stmt)
    return result.scalars().all()  # 返回 DO 对象列表
```

## 下一步

- [模块结构](./03-模块结构.md) - 了解模块组织方式
- [数据库设计](./04-数据库设计.md) - 查看数据库架构
- [API设计](./05-API设计.md) - 学习 API 开发规范
