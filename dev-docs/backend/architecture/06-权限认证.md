# 权限认证系统

## 认证系统概述

系统采用 JWT (JSON Web Token) 进行身份认证,基于 RBAC (Role-Based Access Control) 模型实现权限控制。

## 认证流程

```
1. 用户登录
   ↓
2. 验证用户名密码
   ↓
3. 生成 JWT Token
   ↓
4. 返回 Token 给客户端
   ↓
5. 客户端请求携带 Token
   ↓
6. 服务端验证 Token
   ↓
7. 检查接口权限
   ↓
8. 检查数据权限
   ↓
9. 返回响应
```

## JWT 认证

### 1. Token 生成

**文件**: `utils/jwt_util.py`

```python
import jwt
from datetime import datetime, timedelta
from config.env import JwtConfig

class JwtUtil:
    """JWT 工具类"""
    
    @staticmethod
    def create_access_token(data: dict, expires_delta: timedelta = None):
        """
        生成访问令牌
        
        参数:
        - data: 要编码的数据
        - expires_delta: 过期时间
        
        返回:
        - JWT Token
        """
        to_encode = data.copy()
        
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=JwtConfig.jwt_expire_minutes)
        
        to_encode.update({"exp": expire})
        
        encoded_jwt = jwt.encode(
            to_encode,
            JwtConfig.jwt_secret_key,
            algorithm=JwtConfig.jwt_algorithm
        )
        
        return encoded_jwt
    
    @staticmethod
    def verify_token(token: str):
        """
        验证令牌
        
        参数:
        - token: JWT Token
        
        返回:
        - 解码后的数据
        """
        try:
            payload = jwt.decode(
                token,
                JwtConfig.jwt_secret_key,
                algorithms=[JwtConfig.jwt_algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise TokenExpiredException(message="Token已过期")
        except jwt.JWTError:
            raise TokenInvalidException(message="Token无效")
```

### 2. 登录接口

**文件**: `module_admin/controller/login_controller.py`

```python
from fastapi import APIRouter, Depends
from module_admin.entity.vo.login_vo import LoginModel
from module_admin.service.login_service import LoginService
from utils.response_util import ResponseUtil

router = APIRouter(prefix="/login", tags=["登录"])

@router.post("")
async def login(
    login_data: LoginModel,
    service: LoginService = Depends()
):
    """
    用户登录
    
    参数:
    - username: 用户名
    - password: 密码
    - code: 验证码
    - uuid: 验证码UUID
    
    返回:
    - token: 访问令牌
    """
    result = await service.login(login_data)
    return ResponseUtil.success(data=result)
```

### 3. 登录服务

**文件**: `module_admin/service/login_service.py`

```python
from datetime import timedelta
from module_admin.dao.user_dao import UserDao
from utils.jwt_util import JwtUtil
from utils.pwd_util import PwdUtil
from utils.redis_util import RedisUtil
from exceptions.exception import ServiceException

class LoginService:
    """登录服务"""
    
    async def login(self, login_data: LoginModel):
        """
        用户登录
        """
        # 1. 验证验证码
        await self.verify_captcha(login_data.code, login_data.uuid)
        
        # 2. 查询用户
        user = await self.user_dao.get_user_by_username(login_data.username)
        if not user:
            raise ServiceException(message="用户不存在")
        
        # 3. 验证密码
        if not PwdUtil.verify_password(login_data.password, user.password):
            raise ServiceException(message="密码错误")
        
        # 4. 检查用户状态
        if user.status == "1":
            raise ServiceException(message="用户已停用")
        
        # 5. 生成 Token
        token_data = {
            "user_id": user.user_id,
            "username": user.user_name
        }
        token = JwtUtil.create_access_token(
            data=token_data,
            expires_delta=timedelta(minutes=30)
        )
        
        # 6. 缓存用户信息
        await RedisUtil.set(
            f"user:token:{token}",
            user.dict(),
            expire=1800  # 30分钟
        )
        
        # 7. 记录登录日志
        await self.record_login_log(user, "登录成功")
        
        return {"token": token}
```

### 4. Token 验证

**文件**: `module_admin/aspect/auth.py`

```python
from fastapi import Request, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from utils.jwt_util import JwtUtil
from utils.redis_util import RedisUtil
from exceptions.exception import AuthException

security = HTTPBearer()

async def get_current_user(
    request: Request,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """
    获取当前登录用户
    """
    token = credentials.credentials
    
    # 验证 Token
    payload = JwtUtil.verify_token(token)
    
    # 从缓存获取用户信息
    user = await RedisUtil.get(f"user:token:{token}")
    if not user:
        raise AuthException(message="登录已过期,请重新登录")
    
    # 将用户信息存入请求上下文
    request.state.user = user
    
    return user
```

## RBAC 权限模型

### 权限模型结构

```
用户 (User)
  ↓ N:N
角色 (Role)
  ↓ N:N
菜单/权限 (Menu)
```

### 数据表关系

```sql
-- 用户表
sys_user (user_id, user_name, ...)

-- 角色表
sys_role (role_id, role_name, role_key, ...)

-- 菜单表
sys_menu (menu_id, menu_name, perms, ...)

-- 用户角色关联表
sys_user_role (user_id, role_id)

-- 角色菜单关联表
sys_role_menu (role_id, menu_id)
```

## 接口权限控制

### 1. 权限装饰器

**文件**: `module_admin/aspect/interface_auth.py`

```python
from fastapi import Request, Depends
from module_admin.aspect.auth import get_current_user
from exceptions.exception import PermissionException

class CheckUserInterfaceAuth:
    """
    检查用户接口权限
    """
    
    def __init__(self, perms: str):
        """
        参数:
        - perms: 权限标识,如 "system:user:list"
        """
        self.perms = perms
    
    async def __call__(
        self,
        request: Request,
        current_user: dict = Depends(get_current_user)
    ):
        """
        验证用户是否有指定权限
        """
        # 超级管理员拥有所有权限
        if current_user.get("user_name") == "admin":
            return True
        
        # 获取用户权限列表
        user_perms = await self.get_user_permissions(current_user["user_id"])
        
        # 检查是否有指定权限
        if self.perms not in user_perms:
            raise PermissionException(message=f"无权限访问: {self.perms}")
        
        return True
    
    async def get_user_permissions(self, user_id: int):
        """
        获取用户权限列表
        """
        # 从缓存获取
        cache_key = f"user:perms:{user_id}"
        perms = await RedisUtil.get(cache_key)
        
        if not perms:
            # 从数据库查询
            # 1. 查询用户角色
            # 2. 查询角色菜单
            # 3. 提取权限标识
            perms = await self.query_user_permissions(user_id)
            
            # 缓存权限列表
            await RedisUtil.set(cache_key, perms, expire=3600)
        
        return perms
```

### 2. 使用权限控制

```python
from module_admin.aspect.interface_auth import CheckUserInterfaceAuth

@router.get(
    "/list",
    dependencies=[Depends(CheckUserInterfaceAuth("system:user:list"))]
)
async def get_user_list(...):
    """需要 system:user:list 权限"""
    pass

@router.post(
    "",
    dependencies=[Depends(CheckUserInterfaceAuth("system:user:add"))]
)
async def add_user(...):
    """需要 system:user:add 权限"""
    pass
```

### 3. 权限标识规范

格式: `{模块}:{功能}:{操作}`

```
system:user:list    - 用户列表查询
system:user:query   - 用户详情查询
system:user:add     - 用户新增
system:user:edit    - 用户修改
system:user:remove  - 用户删除
system:user:export  - 用户导出
system:user:import  - 用户导入
system:user:resetPwd - 重置密码
```

## 数据权限控制

### 1. 数据权限类型

```python
class DataScopeType:
    """数据权限类型"""
    ALL = "1"           # 全部数据权限
    CUSTOM = "2"        # 自定义数据权限
    DEPT = "3"          # 本部门数据权限
    DEPT_AND_CHILD = "4"  # 本部门及以下数据权限
    SELF = "5"          # 仅本人数据权限
```

### 2. 数据权限装饰器

**文件**: `module_admin/aspect/data_scope.py`

```python
from fastapi import Request, Depends
from module_admin.aspect.auth import get_current_user

class GetDataScope:
    """
    获取数据权限范围
    """
    
    def __init__(self, table_alias: str = ""):
        """
        参数:
        - table_alias: 表别名
        """
        self.table_alias = table_alias
    
    async def __call__(
        self,
        request: Request,
        current_user: dict = Depends(get_current_user)
    ):
        """
        返回数据权限 SQL
        """
        # 超级管理员查看所有数据
        if current_user.get("user_name") == "admin":
            return ""
        
        # 获取用户角色的数据权限
        roles = await self.get_user_roles(current_user["user_id"])
        
        # 构建数据权限 SQL
        sql_parts = []
        
        for role in roles:
            if role.data_scope == DataScopeType.ALL:
                # 全部数据权限
                return ""
            elif role.data_scope == DataScopeType.CUSTOM:
                # 自定义数据权限
                dept_ids = await self.get_role_dept_ids(role.role_id)
                if dept_ids:
                    sql_parts.append(f"{self.table_alias}.dept_id IN ({','.join(map(str, dept_ids))})")
            elif role.data_scope == DataScopeType.DEPT:
                # 本部门数据权限
                sql_parts.append(f"{self.table_alias}.dept_id = {current_user['dept_id']}")
            elif role.data_scope == DataScopeType.DEPT_AND_CHILD:
                # 本部门及以下数据权限
                dept_ids = await self.get_dept_and_child_ids(current_user['dept_id'])
                sql_parts.append(f"{self.table_alias}.dept_id IN ({','.join(map(str, dept_ids))})")
            elif role.data_scope == DataScopeType.SELF:
                # 仅本人数据权限
                sql_parts.append(f"{self.table_alias}.create_by = '{current_user['user_name']}'")
        
        if sql_parts:
            return " AND (" + " OR ".join(sql_parts) + ")"
        
        return ""
```

### 3. 使用数据权限

```python
@router.get("/list")
async def get_user_list(
    query: UserQueryModel = Depends(),
    data_scope: str = Depends(GetDataScope("u")),  # u 是表别名
    service: UserService = Depends()
):
    # data_scope 包含数据权限 SQL
    result = await service.get_user_list(query, data_scope)
    return ResponseUtil.success(data=result)
```

在 DAO 层应用数据权限:

```python
async def get_user_list(self, query: UserQueryModel, data_scope: str = ""):
    stmt = select(SysUser.alias("u"))
    
    # 添加查询条件
    conditions = []
    if query.user_name:
        conditions.append(SysUser.user_name.like(f"%{query.user_name}%"))
    
    # 添加数据权限条件
    if data_scope:
        stmt = stmt.where(text(data_scope))
    
    if conditions:
        stmt = stmt.where(and_(*conditions))
    
    result = await self.db.execute(stmt)
    return result.scalars().all()
```

## 密码安全

### 1. 密码加密

**文件**: `utils/pwd_util.py`

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class PwdUtil:
    """密码工具类"""
    
    @staticmethod
    def get_password_hash(password: str) -> str:
        """
        密码加密
        """
        return pwd_context.hash(password)
    
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """
        验证密码
        """
        return pwd_context.verify(plain_password, hashed_password)
```

### 2. 密码策略

- 最小长度: 6位
- 包含字母和数字
- 定期更换密码
- 密码不能与用户名相同
- 密码错误次数限制

## 登录安全

### 1. 验证码

```python
from captcha.image import ImageCaptcha
import uuid

class CaptchaUtil:
    """验证码工具类"""
    
    @staticmethod
    async def generate_captcha():
        """
        生成验证码
        """
        # 生成随机验证码
        code = ''.join(random.choices(string.digits, k=4))
        
        # 生成图片
        image = ImageCaptcha()
        data = image.generate(code)
        
        # 生成 UUID
        captcha_uuid = str(uuid.uuid4())
        
        # 缓存验证码
        await RedisUtil.set(
            f"captcha:{captcha_uuid}",
            code,
            expire=300  # 5分钟
        )
        
        return {
            "uuid": captcha_uuid,
            "img": base64.b64encode(data.getvalue()).decode()
        }
```

### 2. 登录失败限制

```python
async def check_login_limit(username: str):
    """
    检查登录失败次数
    """
    key = f"login:fail:{username}"
    fail_count = await RedisUtil.get(key) or 0
    
    if fail_count >= 5:
        raise ServiceException(message="登录失败次数过多,请30分钟后再试")
    
    return fail_count

async def record_login_fail(username: str):
    """
    记录登录失败
    """
    key = f"login:fail:{username}"
    fail_count = await RedisUtil.incr(key)
    
    if fail_count == 1:
        await RedisUtil.expire(key, 1800)  # 30分钟
```

### 3. 单点登录

```python
async def check_single_login(user_id: int, new_token: str):
    """
    检查单点登录
    """
    # 获取用户当前 Token
    old_token = await RedisUtil.get(f"user:login:{user_id}")
    
    if old_token and old_token != new_token:
        # 删除旧 Token
        await RedisUtil.delete(f"user:token:{old_token}")
    
    # 保存新 Token
    await RedisUtil.set(f"user:login:{user_id}", new_token)
```

## 在线用户管理

### 1. 在线用户列表

```python
async def get_online_users():
    """
    获取在线用户列表
    """
    # 获取所有在线用户 Token
    keys = await RedisUtil.keys("user:token:*")
    
    online_users = []
    for key in keys:
        user = await RedisUtil.get(key)
        if user:
            online_users.append(user)
    
    return online_users
```

### 2. 强制下线

```python
async def force_logout(token: str):
    """
    强制用户下线
    """
    # 删除 Token 缓存
    await RedisUtil.delete(f"user:token:{token}")
    
    # 删除用户登录记录
    user = await RedisUtil.get(f"user:token:{token}")
    if user:
        await RedisUtil.delete(f"user:login:{user['user_id']}")
```

## 最佳实践

### 1. Token 管理
- Token 设置合理的过期时间
- 使用 Redis 缓存 Token
- 支持 Token 刷新机制
- 登出时清除 Token

### 2. 权限缓存
- 缓存用户权限列表
- 角色权限变更时清除缓存
- 设置合理的缓存过期时间

### 3. 安全加固
- 使用 HTTPS 传输
- Token 存储在 HTTP-Only Cookie
- 实施 CSRF 防护
- 记录安全审计日志

### 4. 密码安全
- 使用强密码策略
- 密码加密存储
- 定期更换密码
- 密码找回验证

## 下一步

- [开发规范](./07-开发规范.md) - 编码标准和最佳实践
